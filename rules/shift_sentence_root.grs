rule rev_root_modal_aux_to_lexical_verb {
  pattern {
    AUX [lemma="ville"|"kunne"|"måtte"|"skulle"|"burde"];
    LEX [upos=VERB];
    r1: R -[FINV]-> AUX;
    e: AUX -[INFV]-> LEX;
  }
  commands {
    del_edge e;
    del_edge r1;
    shift AUX ==> LEX;
    add_edge r2: R -> LEX; r2.label = root;
    add_edge LEX -[aux]-> AUX;
  }
}

rule rev_root_modal_aux_chain_to_lexical {
  pattern {
    AUX1 [upos=AUX, lemma="ville"|"kunne"|"måtte"|"skulle"|"burde"];
    AUX2 [upos=AUX];
    AUX3 [upos=AUX];
    e1: AUX1 -[INFV]-> AUX2;
    e2: AUX2 -[INFV]-> AUX3;
    e3: AUX3 -[SPRED]-> PRED;
  }
  commands {
    del_edge e1;
    del_edge e2;
    del_edge e3;
    shift AUX1 ==> PRED;
    shift AUX2 ==> PRED;
    shift AUX3 ==> PRED;
    add_edge PRED -[aux]-> AUX1;
    add_edge PRED -[aux]-> AUX2;
    add_edge PRED -[aux]-> AUX3;
  }
}


rule shift_root_auxiliary_copula_predicate {
% F.eks. "Aftenposten fikk være med på ..."
    pattern {

        % nodes
        H[upos=AUX];
        AUX[upos=AUX, lemma="være"];
        PRED[upos=ADP];

        % dependencies
        r: R -[FINV]-> H;
        e1: H -[INFV]-> AUX;
        e2: AUX -[SPRED]-> PRED;
    }
    commands {
        del_edge r;
        del_edge e1;
        del_edge e2;
        shift H ==> PRED;
        shift AUX ==> PRED;
        add_edge nr: R -> PRED; nr.label = root;
        add_edge n1: PRED -> H; n1.label = aux;
        add_edge n2: PRED -> AUX; n2.label = cop;
    }
}


rule c2sh_PUTFYLL {
  pattern {
    H -[PUTFYLL]-> N1;
    e: N1 -[PUTFYLL]-> N2;
  }
  without {
    * -[PUTFYLL]-> H;
  }
  commands {
    del_edge e;
    add_edge H -[PUTFYLL]-> N2;
  }
}


rule rev_PUTFYLL_bouquet_head {
  pattern {
    ADP[upos=ADP];
    N [upos=NOUN];
    e1: S -[SPRED]-> ADP;
    e: ADP -[PUTFYLL]-> N;

  }
  commands {
    del_edge e;
    del_edge e1;
    shift ADP ==> N;
    add_edge f: N -> ADP; f.label = case;
    add_edge S -[SPRED]-> N;
  }
}


rule shift_root_copula_predicate {
% F.eks. "[WHO] er sterkt inne i bildet."
    pattern {

        % nodes
        AUX[upos=AUX, lemma="være"];
        % dependencies
        r: R -[FINV]-> AUX;
        e: AUX -[SPRED]-> PRED;
    }
    commands {
        del_edge r;
        del_edge e;
        shift AUX ==> PRED;
        add_edge nr: R -> PRED; nr.label = root;
        add_edge ne: PRED -> AUX; ne.label = cop;
    }
}

strat shift_copula_SPRED_head {
  Seq (
    Onf (c2sh_PUTFYLL),
    Onf (rev_PUTFYLL_bouquet_head),
    Onf (shift_root_copula_predicate)
  )
}
