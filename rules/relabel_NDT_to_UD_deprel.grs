% relabel edges: Change NDT dependency relation to UD deprel with 1 to 1 mappings

rule punctuation_sentence_end {
  pattern { e: N -[ IP ]-> P }
  commands { e.label = punct }
}

rule punctuation_mid_sentence {
  pattern { e: N -[ IK ]-> P;  }
  commands { e.label = punct }
}

rule nominal_subject {
  pattern { DEP [upos<>VERB]; e: GOV -[SUBJ]-> DEP; }
    without {
    DEP -[cop]-> *;
  }
  commands { e.label = nsubj }
}

rule clausal_subject {
  pattern { DEP [upos=VERB]; e: GOV -[SUBJ]-> DEP; }
  commands { e.label = csubj }
}

rule copular_clausal_subject {
  pattern { e1: GOV -[SUBJ]-> DEP;
            e2: DEP -[cop]-> D2; }
  commands { e1.label = csubj }
}

rule root_finite_verb {
  pattern { e: GOV -[ FINV ]-> DEP }
  commands { e.label = root }
}

rule expletive_subj {
  pattern { e: GOV -[ FSUBJ ]-> DEP }
  commands { e.label = expl }
}

rule expletive_obj {
  pattern { e: GOV -[ FOBJ ]-> DEP }
  commands { e.label = expl }
}

rule indirect_obj {
  pattern { e: GOV -[ IOBJ ]-> DEP }
  commands { e.label = iobj }
}

rule subj_predicative {
  pattern { e: GOV -[ SPRED ]-> DEP }
  commands { e.label = xcomp } % copular constr. should be no problem, since they are converted first in reverse_heads
}

rule obj_predicative {
  pattern { e: GOV -[ OPRED ]-> DEP }
  commands { e.label = xcomp }
}

rule interjection {
  pattern { e: GOV -[ INTERJ ]-> DEP }
  commands { e.label = discourse  }
}

rule coordinating_conjuction {
  pattern { e: GOV -[ KONJ ]-> DEP }
  commands { e.label = cc }
}

rule conjunct {
  pattern { e: GOV -[ KOORD ]-> DEP }
  commands { e.label = conj }
}

rule coordination_verbal_ellipsis {
  pattern { e: GOV -[ KOORD-ELL ]-> DEP }
  commands { e.label = conj }
}

rule subclause_at {
  pattern { DEP [form="at"]; e: GOV -[SBU]-> DEP;}
  commands { e.label = mark }
}

rule subclause_aa {
  pattern { DEP [form="å"]; e: GOV -[INFV]-> DEP;}  % after the relation between the infinite verb and the marker has been reversed/shifted
  commands { e.label = mark }
}

rule determiner {
  pattern { GOV [upos= NOUN|PROPN]; DEP [upos=DET|NUM]; e: GOV -[DET]-> DEP; }
  commands { e.label = det }
}

rule determiner_genitive {
  pattern { GOV [upos= NOUN|PROPN]; DEP [upos=PROPN, Case=Gen]; e: GOV -[DET]-> DEP; }
  commands { e.label = det }
}

rule determiner_flat_name_genitive {
  pattern { GOV [upos= NOUN|PROPN]; DEP [upos=PROPN]; DEP2[Case=Gen]; e: GOV -[DET]-> DEP; DEP -[FLAT|flat]-> DEP2;}
  commands { e.label = det }
}

rule determiner_possessive {
  pattern { GOV [upos= NOUN|PROPN]; DEP [upos=PRON, Poss=Yes]; e: GOV -[DET]-> DEP; }
  commands { e.label = det }
}

rule adjectival_modifier {
  pattern { GOV [upos = NOUN|PROPN]; DEP [upos=ADJ]; e: GOV -[ ATR ]-> DEP; }
  commands { e.label = amod }
}

rule nominal_modifier {
  pattern { GOV [upos = NOUN|PROPN]; DEP [upos=NOUN]; e: GOV -[ ATR ]-> DEP; }
  commands { e.label = nmod }
}

rule adverbial_modifier {
  pattern {
    DEP [ upos=ADV|PART ];
    e: GOV -[ADV]-> DEP;
  }
  commands { e.label = advmod }
}

rule oblique_nominal {
  pattern {
    DEP [ upos= NOUN|PROPN  ];
    e: GOV -[ADV]-> DEP;
  }
  commands { e.label = obl }
}

rule flat_names {
  pattern { e: GOV -[FLAT]-> DEP; }
  commands { e.label = flat }
}

rule appositional_modifier {
  pattern { e: GOV -[APP]-> DEP; }
  commands { e.label = appos }
}

% presenteringssetninger: når "være" er rot og setningen har PSUBJ og FSUBJ. Behold roten.
% forutsetter at strukturen ikke er endret.
rule presentational_expl {
  pattern {
    D1 [ upos <> VERB|ADP ];
    e1: H -[PSUBJ]-> D1;
    e2: H -[FSUBJ]-> D2;
  }
  without { H -[cop]-> *; }
  commands {
    e1.label = nsubj;
    e2.label = expl;
  }
}

rule fsubj_psubj_verb {
  pattern {
    D1 [ upos = VERB ];
    e1: H -[PSUBJ]-> D1;
    e2: H -[FSUBJ]-> D2;
  }
  commands {
    e1.label = csubj;
    e2.label = expl;
  }
}


rule only_psubj_nom {
  pattern {
    D [ upos <> VERB|ADP ];
    e: H -[PSUBJ]-> D;
  }
  without { H -[FSUBJ]-> *;
            H -[cop]-> *;}
  commands {
    e.label = nsubj;
  }
}

rule only_psubj_vb {
  pattern {
    D [ upos = VERB ];
    e: H -[PSUBJ]-> D;
  }
  without { H -[FSUBJ]-> *; }
  commands {
    e.label = csubj;
  }
}


% "være" and "ha" can both be temporal auxiliaries in a passive construction, but only "bli" gets the "aux:pass" relation
rule passive_lex_aux_bli {
  pattern {
    A [ upos=AUX, lemma="bli" ];
    V [ upos=VERB, VerbForm=Part ];
    e: V -> A;  % after the lexical verb is already the head
  }
  without { e.2 = pass; }
  commands {
    e.2 = pass;
  }
}

rule temporal_aux_vare_ha {
  pattern {
    A [ upos=AUX, lemma="være"|"ha" ];
    V [ upos=VERB|AUX, VerbForm=Part ];
    e: V -> A;
  }
  without {
    e.label = aux;
  }
  commands {
    e.label = aux;
  }
}

% passive subject is the dependent of a verb with passive marking or a participle with a passive auxiliary attached
rule passive_subject_verbform {
  pattern {
    V [ upos=VERB, Voice=Pass, form=re".*s" ];
    e: V -[ 1=nsubj|csubj ]-> S;
  }
  without {
    e.2 = pass;
  }
  commands {
    e.2 = pass;
  }
}

% participle with a passive auxiliary attached
rule passive_subject_periphrastic {
  pattern {
    V [ VerbForm=Part ];
    V -[1=aux, 2=pass]-> *;
    e: V -[ 1=nsubj|csubj ]-> S;
  }
  without {
    e.2 = pass;
  }
  commands {
    e.2 = pass;
  }
}

